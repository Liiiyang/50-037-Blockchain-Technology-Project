'''
Reference: 
	https://github.com/adilmoujahid/blockchain-python-tutorial/blob/master/blockchain_client/blockchain_client.py

Other references:
Instantiating using python class methods: 
	https://stackoverflow.com/questions/13260557/create-new-class-instance-from-class-method
	https://stackoverflow.com/questions/12179271/meaning-of-classmethod-and-staticmethod-for-beginner
Converting JSON string to Python object:
	https://stackoverflow.com/questions/6578986/how-to-convert-json-data-into-a-python-object
ECDSA library documentation:
	https://github.com/warner/python-ecdsa

'''
import json
import hashlib
from ecdsa import SigningKey, NIST192p
from collections import namedtuple

# data = '{"name": "John Smith", "hometown": {"name": "New York", "id": 123}}'
# x = json.loads(data, object_hook=lambda d: namedtuple('X', d.keys())(*d.values()))
# print x.name, x.hometown.name, x.hometown.id

class Transaction():
  def __init__(self, rcv, snd, amt, cmmt):
    self.receiver = rcv
    self.sender = snd       # public key of receiver
    self.amount = amt
    self.comment = cmmt      # arbitrary text, can be empty
    self.signature = ""  # sender's signature protecting the transaction: Generated by using sender's private key.

  @classmethod
  def new(cls, rcv, snd, amt, private_key_str, cmmt=""):
    # def new(cls, recepient, sender, amount, private_key, comment=""):
    # Instantiates object from passed values
    #
    # Convert to JSON string
    # Sign JSON string with private key
    # Insert signature to object
    # return object
    
    myTxObj = cls(rcv, snd, amt, cmmt)
    sig = myTxObj.sign(private_key_str)
    myTxObj.signature = sig
    return myTxObj

  def to_json(self):
    # Serializes object to JSON string
    return json.dumps(self.__dict__)

  @classmethod
  def from_json(cls, jsonString):
    # Instantiates/Deserializes object from JSON string
    x = json.loads(jsonString, object_hook=lambda d: namedtuple('X', d.keys())(*d.values()))
    return x

  # private method
  def sign(self, private_key_str):
    # Sign object with private key passed
    # That can be called within new()
    sk = SigningKey.from_string(private_key_str, curve=NIST192p)
    msg = self.to_json()
    sig = sk.sign(msg.encode())
    # self.signature = sig
    return sig

  def validate(self, msg, pubkey):
    # Validate transaction correctness.
    # Can be called within from_json()
    # h = hashlib.sha256(self.signature+obj).hexdigest()
    if h == sig:
      isValid = True
    else: 
      isValid = False
    return isValid
  def __eq__(trans1, trans2):
    # Check whether transactions are the same
    if trans1 == trans2:
      return True
    else:
      return False
   